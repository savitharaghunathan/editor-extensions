import * as pathlib from "path";
import { Logger } from "winston";
import { createHash } from "crypto";
import { EnhancedIncident } from "@editor-extensions/shared";
import { AIMessage, AIMessageChunk } from "@langchain/core/messages";
import { Annotation, type MessagesAnnotation } from "@langchain/langgraph";
import { CompiledStateGraph, END, START, StateGraph } from "@langchain/langgraph";

import {
  KaiUserInteractionMessage,
  type PendingUserInteraction,
  type KaiWorkflow,
  type KaiWorkflowInitOptions,
  type KaiWorkflowInput,
  type KaiWorkflowMessage,
  type KaiWorkflowResponse,
  KaiWorkflowMessageType,
} from "../types";
import {
  SummarizeAdditionalInfoOutputState,
  AnalysisIssueFixOrchestratorState,
  SummarizeHistoryOutputState,
  AnalysisIssueFixOutputState,
} from "../schemas/analysisIssueFix";
import { fileUriToPath } from "../utils";
import { FileSystemTools } from "../tools/filesystem";
import { KaiWorkflowEventEmitter } from "../eventEmitter";
import { AnalysisIssueFix } from "../nodes/analysisIssueFix";
import { JavaDependencyTools } from "../tools/javaDependency";
import { DiagnosticsIssueFix } from "../nodes/diagnosticsIssueFix";
import { AgentName, DiagnosticsOrchestratorState } from "../schemas/diagnosticsIssueFix";

export interface KaiInteractiveWorkflowInput extends KaiWorkflowInput {
  programmingLanguage: string;
  migrationHint: string;
  enableAgentMode: boolean;
}

// output state of the initial analysis workflow
const AnalysisWorkflowOutputState = Annotation.Root({
  ...AnalysisIssueFixOutputState.spec,
  ...SummarizeAdditionalInfoOutputState.spec,
  ...SummarizeHistoryOutputState.spec,
});

// overall state of the initial analysis workflow
const AnalysisWorkflowOverallState = Annotation.Root({
  ...AnalysisIssueFixOrchestratorState.spec,
  ...AnalysisWorkflowOutputState.spec,
});

/**
 * Agentic workflow that takes a list of incidents as input
 * and fixes all incidents as well as addresses any additional
 * changes needed elsewhere in the project. The workflow works
 * as follows - first, it iterates over all incidents grouped
 * by files and generates fixes using the analysis fix node
 * second, it captures output generated by the analysis fix node
 * and passes it to summarize node that summarizes any further
 * changes needed. finally, the accumulated output are passed to
 * another workflow which - first, addresses any additional info
 * generated by first workflow. once all of the changes from it
 * are addressed, waits for the IDE to send in diagnostics. the
 * second workflow is interactive in that it asks for confirmation
 * from the user before starting agents on any new work
 */
export class KaiInteractiveWorkflow
  extends KaiWorkflowEventEmitter
  implements KaiWorkflow<KaiInteractiveWorkflowInput>
{
  // workflow that generates the initial fixes for analysis issues
  // spits out modified files and summary of changes & additional information
  private analysisFixWorkflow: CompiledStateGraph<any, any, any, any, any> | undefined;
  // workflow that starts after initial analysis fixes are done, it uses
  // additional info as starting input to make more changes, also waits
  // on diagnostics info to arrive from IDE to make any more changes afterwards
  private followUpInteractiveWorkflow:
    | CompiledStateGraph<any, any, string, any, any, any>
    | undefined;
  private diagnosticsNodes: DiagnosticsIssueFix | undefined;

  private userInteractionPromises: Map<string, PendingUserInteraction>;
  private readonly logger: Logger;
  private workspaceDir: string;

  constructor(logger: Logger) {
    super();
    this.diagnosticsNodes = undefined;
    this.analysisFixWorkflow = undefined;
    this.followUpInteractiveWorkflow = undefined;
    this.userInteractionPromises = new Map<string, PendingUserInteraction>();
    this.logger = logger.child({
      component: "KaiInteractiveWorkflow",
    });
    this.workspaceDir = "";

    this.runToolsEdgeFunction = this.runToolsEdgeFunction.bind(this);
    this.analysisIssueFixRouterEdge = this.analysisIssueFixRouterEdge.bind(this);
    this.diagnosticsOrchestratorEdge = this.diagnosticsOrchestratorEdge.bind(this);
  }

  async init(options: KaiWorkflowInitOptions): Promise<void> {
    this.workspaceDir = fileUriToPath(options.workspaceDir);
    const fsTools = new FileSystemTools(this.workspaceDir, options.fsCache, this.logger);
    const depTools = new JavaDependencyTools(options.toolCache, this.logger);

    const analysisIssueFixNodes = new AnalysisIssueFix(
      options.modelProvider,
      fsTools.all(),
      options.fsCache,
      this.workspaceDir,
      options.solutionServerClient,
      this.logger.child({
        component: "AnalysisIssueFixNode",
      }),
    );
    // relay events from nodes back to callers
    analysisIssueFixNodes.on("workflowMessage", async (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });
    fsTools.on("workflowMessage", async (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });

    this.diagnosticsNodes = new DiagnosticsIssueFix(
      options.modelProvider,
      fsTools.all(),
      depTools.all(),
      this.workspaceDir,
      this.logger.child({
        component: "DiagnosticsNode",
      }),
    );
    this.diagnosticsNodes.on("workflowMessage", async (msg: KaiWorkflowMessage) => {
      this.emitWorkflowMessage(msg);
    });

    this.analysisFixWorkflow = new StateGraph({
      input: AnalysisIssueFixOrchestratorState,
      output: AnalysisWorkflowOutputState,
      stateSchema: AnalysisWorkflowOverallState,
    })
      // router node that iterates through incidents by uris and fixes them one by one before moving on
      .addNode("fix_analysis_issue_router", analysisIssueFixNodes.fixAnalysisIssueRouter)
      // node responsible for fixing analysis issues in one file (low effort prompt)
      .addNode("fix_analysis_issue", analysisIssueFixNodes.fixAnalysisIssue)
      // node responsible for summarizing additional information spit by fix_analysis_issue
      .addNode(
        "summarize_additional_information",
        analysisIssueFixNodes.summarizeAdditionalInformation,
      )
      // node responsible for summarizing changes made by fix_analysis_issue to be used as background by planner
      .addNode("summarize_history", analysisIssueFixNodes.summarizeHistory)
      // start with router
      .addEdge(START, "fix_analysis_issue_router")
      // router loops over all incidents and decides when to go to additional info
      .addConditionalEdges("fix_analysis_issue_router", this.analysisIssueFixRouterEdge, [
        "fix_analysis_issue",
        "summarize_additional_information",
        "summarize_history",
        "fix_analysis_issue_router",
        END,
      ])
      // go back to router with response, router decides what to do next
      .addEdge("fix_analysis_issue", "fix_analysis_issue_router")
      .addEdge("summarize_additional_information", END)
      .addEdge("summarize_history", END)
      .compile();

    this.followUpInteractiveWorkflow = new StateGraph({
      input: DiagnosticsOrchestratorState,
      output: DiagnosticsOrchestratorState,
      stateSchema: DiagnosticsOrchestratorState,
    })
      // node that orchestrates planning and invoking of other agents
      .addNode("orchestrate_plan_and_execution", this.diagnosticsNodes.orchestratePlanAndExecution)
      // node that plans fixes and distributes work to specialized agents
      .addNode("plan_fixes", this.diagnosticsNodes.planFixes)
      // node that is responsible for fixing issues that don't have a specialized agent available for
      .addNode("fix_general_issues", this.diagnosticsNodes.fixGeneralIssues)
      // node responsible for fixing dependency issues
      .addNode("fix_java_dep_issues", this.diagnosticsNodes.fixJavaDependencyIssues)
      // node responsible for handling tool calls by the general agent
      .addNode("tools_fix_general_issues", this.diagnosticsNodes.runTools)
      // node responsible for handling tool calls by the dep agent
      .addNode("tools_fix_dep_issues", this.diagnosticsNodes.runTools)
      .addEdge("tools_fix_general_issues", "fix_general_issues")
      .addEdge("tools_fix_dep_issues", "fix_java_dep_issues")
      .addEdge("plan_fixes", "orchestrate_plan_and_execution")
      .addEdge(START, "orchestrate_plan_and_execution")
      .addConditionalEdges(
        "fix_general_issues",
        this.runToolsEdgeFunction("tools_fix_general_issues", "orchestrate_plan_and_execution"),
        ["tools_fix_general_issues", "orchestrate_plan_and_execution"],
      )
      .addConditionalEdges(
        "fix_java_dep_issues",
        this.runToolsEdgeFunction("tools_fix_dep_issues", "orchestrate_plan_and_execution"),
        ["tools_fix_dep_issues", "orchestrate_plan_and_execution"],
      )
      .addConditionalEdges("orchestrate_plan_and_execution", this.diagnosticsOrchestratorEdge, [
        "plan_fixes",
        "fix_java_dep_issues",
        "fix_general_issues",
        "orchestrate_plan_and_execution",
        END,
      ])
      .compile();
  }

  async run(input: KaiInteractiveWorkflowInput): Promise<KaiWorkflowResponse> {
    if (!this.analysisFixWorkflow || !(this.analysisFixWorkflow instanceof CompiledStateGraph)) {
      throw new Error(`Workflow must be inited before it can be run`);
    }

    const incidentsByUris: Array<{ uri: string; incidents: EnhancedIncident[] }> =
      input.incidents
        ?.reduce(
          (acc, incident) => {
            const existingEntry = acc.find(
              (entry: { uri: string; incidents: EnhancedIncident[] }) =>
                entry.uri === fileUriToPath(incident.uri),
            );
            if (existingEntry) {
              existingEntry.incidents.push(incident);
            } else {
              acc.push({
                uri: fileUriToPath(incident.uri),
                incidents: [incident],
              });
            }
            return acc;
          },
          [] as Array<{ uri: string; incidents: EnhancedIncident[] }>,
        )
        ?.sort((a, b) => a.uri.localeCompare(b.uri))
        ?.map((entry) => ({
          ...entry,
          incidents: entry.incidents.sort((a, b) => a.uri.localeCompare(b.uri)),
        })) ?? [];

    const cacheSubDir = this.createIncidentsHash(incidentsByUris);
    this.logger.debug(`Using cache directory '${cacheSubDir}' for this run`);

    const graphInput: typeof AnalysisIssueFixOrchestratorState.State = {
      inputIncidentsByUris: incidentsByUris,
      currentIdx: 0,
      migrationHint: input.migrationHint,
      programmingLanguage: input.programmingLanguage,
      enableAdditionalInformation: input.enableAgentMode ?? false,
      cacheSubDir,
      // internal fields
      inputFileContent: undefined,
      inputFileUri: undefined,
      inputIncidents: [],
      inputAllAdditionalInfo: undefined,
      inputAllReasoning: undefined,
      inputAllModifiedFiles: [],
      outputAdditionalInfo: undefined,
      outputReasoning: undefined,
      outputUpdatedFile: undefined,
      outputUpdatedFileUri: undefined,
      outputHints: [],
      outputAllResponses: [],
      iterationCount: 0,
    };

    const runResponse: KaiWorkflowResponse = {
      errors: [],
      modified_files: [],
    };

    // first run the analysis fix workflow
    const analysisFixOutputState: typeof AnalysisWorkflowOutputState.State =
      await this.analysisFixWorkflow.invoke(graphInput, {
        recursionLimit: incidentsByUris.length * 2 + 10,
      });

    let shouldAddressAdditionalInfo = false;
    // if there is any additional information spit by analysis workflow, capture that
    const additionalInformation: string = analysisFixOutputState.summarizedAdditionalInfo;
    if (
      input.enableAgentMode &&
      additionalInformation.length > 0 &&
      !additionalInformation.includes("NO-CHANGE")
    ) {
      // wait for user confirmation
      const id = `req-${Date.now()}`;
      const userConfirmationPromise = new Promise<KaiUserInteractionMessage>((resolve, reject) => {
        this.userInteractionPromises.set(id, {
          resolve,
          reject,
        });
      });
      this.emitWorkflowMessage({
        id,
        type: KaiWorkflowMessageType.UserInteraction,
        data: {
          type: "yesNo",
          systemMessage: {
            yesNo: "I found more changes to address. Do you want me to continue fixing them?",
          },
        },
      });
      try {
        const response = await userConfirmationPromise;
        if (response.data.response && (response.data.response.yesNo ?? false)) {
          shouldAddressAdditionalInfo = true;
        }
      } catch (e) {
        this.logger.error(`Failed to wait for user response`, e);
      } finally {
        this.userInteractionPromises.delete(id);
      }
    }

    // run the interactive workflow for further issues
    const interactiveWorkflowInput: typeof DiagnosticsOrchestratorState.State = {
      inputSummarizedAdditionalInfo:
        (input.enableAgentMode ?? false) && shouldAddressAdditionalInfo
          ? additionalInformation
          : undefined,
      migrationHint: input.migrationHint,
      programmingLanguage: input.programmingLanguage,
      plannerInputAgents: ["generalFix", "javaDependency"],
      plannerInputBackground: analysisFixOutputState.summarizedHistory,
      enableDiagnosticsFixes: input.enableAgentMode ?? false,
      cacheSubDir,
      // internal fields
      inputDiagnosticsTasks: undefined,
      currentAgent: undefined,
      currentTask: undefined,
      inputInstructionsForGeneralFix: undefined,
      inputUrisForGeneralFix: undefined,
      messages: [],
      outputModifiedFilesFromGeneralFix: undefined,
      plannerOutputNominatedAgents: undefined,
      plannerInputTasks: undefined,
      shouldEnd: false,
      iterationCount: analysisFixOutputState.iterationCount,
    };

    await this.followUpInteractiveWorkflow?.invoke(interactiveWorkflowInput, {
      // each state change is one iteration, keeping this really high
      // users can ask to stop at any point. fixing analysis issues in a file
      // followed by adding a dependency to the pom is roughly 10 iterations if
      // the agent can find the pom file in the first attempt
      recursionLimit: 3000,
    });

    this.emitWorkflowMessage({
      id: "interactive_workflow_done",
      type: KaiWorkflowMessageType.LLMResponseChunk,
      data: new AIMessageChunk("Done addressing all issues. Goodbye!"),
    });

    return runResponse;
  }

  async resolveUserInteraction(response: KaiUserInteractionMessage): Promise<void> {
    // if the response has tasks, the diagnosis orchestrator node should handle it
    if (
      response.type === KaiWorkflowMessageType.UserInteraction &&
      response.data.type === "tasks"
    ) {
      await this.diagnosticsNodes?.resolveDiagnosticsPromise(response);
      return;
    }
    const promise = this.userInteractionPromises.get(response.id);
    if (!promise) {
      return;
    }
    const { data } = response;
    if (!data.response || (!data.response.choice && data.response.yesNo === undefined)) {
      promise.reject(Error(`Invalid response from user`));
    }
    promise.resolve(response);
  }

  // edge responsible for invoking analysis issue fix node until all issues
  // are resolved. when resolved, moves onto addressing additional information
  async analysisIssueFixRouterEdge(
    state: typeof AnalysisIssueFixOrchestratorState.State,
  ): Promise<string | string[]> {
    this.logger.debug(`Edge function called with state:`, {
      hasInputFileContent: !!state.inputFileContent,
      hasInputFileUri: !!state.inputFileUri,
      hasInputIncidents: !!state.inputIncidents && state.inputIncidents.length > 0,
      hasOutputUpdatedFile: !!state.outputUpdatedFile,
      hasOutputUpdatedFileUri: !!state.outputUpdatedFileUri,
      currentIdx: state.currentIdx,
      totalIncidents: state.inputIncidentsByUris.length,
      enableAdditionalInformation: state.enableAdditionalInformation,
      hasInputAllAdditionalInfo: !!state.inputAllAdditionalInfo,
      hasInputAllReasoning: !!state.inputAllReasoning,
    });

    // if these attributes are available, router meant to solve the analysis issue
    if (state.inputFileContent && state.inputFileUri && state.inputIncidents.length > 0) {
      return "fix_analysis_issue";
    }

    // if there was a response, router needs to accumulate it
    if (state.outputUpdatedFile && state.outputUpdatedFileUri) {
      this.logger.debug(`Going to fix_analysis_issue_router to accumulate response`);
      return "fix_analysis_issue_router";
    }

    // if there were any errors earlier in the router, go back to router
    // this will make router pick up the next incident in list
    if (
      state.currentIdx < state.inputIncidentsByUris.length &&
      (!state.inputFileContent || !state.inputFileUri || state.inputIncidents.length === 0)
    ) {
      this.logger.debug(`Going back to fix_analysis_issue_router for next incident`);
      return "fix_analysis_issue_router";
    }

    // if the router accumulated all responses, we need to go to additional information
    if (state.enableAdditionalInformation) {
      if (state.inputAllAdditionalInfo && state.inputAllReasoning) {
        this.logger.debug(`Going to summarize both additional info and history`);
        return ["summarize_additional_information", "summarize_history"];
      } else if (state.inputAllAdditionalInfo) {
        this.logger.debug(`Going to summarize additional information only`);
        return "summarize_additional_information";
      } else {
        // Additional information is enabled but not accumulated yet
        // This means we need to go back to router to continue processing
        this.logger.debug(
          `Additional info enabled but not accumulated, going to fix_analysis_issue_router`,
        );
        return "fix_analysis_issue_router";
      }
    }
    return END;
  }

  // edge for the orchestrator to delegate work to planner and sub-agents
  async diagnosticsOrchestratorEdge(
    state: typeof DiagnosticsOrchestratorState.State,
  ): Promise<string> {
    if (state.shouldEnd) {
      this.logger.silly("Going to END because shouldEnd is true");
      return END;
    }
    // if an agent is picked, we need to invoke it to do the next task
    if (state.currentAgent) {
      switch (state.currentAgent as AgentName) {
        case "generalFix":
          this.logger.silly("Going to fix_general_issues because currentAgent is generalFix");
          return "fix_general_issues";
        case "javaDependency":
          this.logger.silly("Going to fix_java_dep_issues because currentAgent is javaDependency");
          return "fix_java_dep_issues";
        default:
          this.logger.silly(
            "Going to orchestrate_plan_and_execution because currentAgent is default",
          );
          return "orchestrate_plan_and_execution";
      }
    }
    // if there is a task, we need the planner to act on it
    if (state.currentTask) {
      this.logger.silly("Going to plan_fixes because currentTask is present");
      return "plan_fixes";
    }
    return "orchestrate_plan_and_execution";
  }

  // generates an edge function to connect agent nodes with tool nodes and their orchestrator nodes
  // returnNode is the orchestrator
  private runToolsEdgeFunction(
    toolNode: string,
    returnNode: string,
  ): (state: typeof MessagesAnnotation.State) => Promise<string> {
    return async (state: typeof MessagesAnnotation.State): Promise<string> => {
      if (!state.messages) {
        this.logger.silly("Going to returnNode because messages is undefined");
        return returnNode;
      }
      const lastMessage = state.messages[state.messages.length - 1];
      if (lastMessage instanceof AIMessage || lastMessage instanceof AIMessageChunk) {
        return lastMessage.tool_calls && lastMessage.tool_calls.length > 0 ? toolNode : returnNode;
      } else {
        return returnNode;
      }
    };
  }

  // used as a name for the subdirectory in the cache to store the results of current run
  private createIncidentsHash(
    incidentsByUris: Array<{ uri: string; incidents: EnhancedIncident[] }>,
  ): string {
    const dataString = incidentsByUris
      .map(({ uri, incidents }) => {
        const incidentsData = incidents
          .map((incident) => ({
            lineNumber: incident.lineNumber,
            uri: pathlib.relative(this.workspaceDir, fileUriToPath(incident.uri)),
            message: incident.message,
            violationId: incident.violationId,
            ruleset_name: incident.ruleset_name,
            violation_name: incident.violation_name,
            violation_category: incident.violation_category,
          }))
          .sort((a, b) => {
            const lineCompare = (a.lineNumber || 0) - (b.lineNumber || 0);
            return lineCompare !== 0 ? lineCompare : a.violationId.localeCompare(b.violationId);
          });

        return {
          uri: pathlib.relative(this.workspaceDir, fileUriToPath(uri)),
          incidents: incidentsData,
        };
      })
      .sort((a, b) => a.uri.localeCompare(b.uri))
      .map((item) => JSON.stringify(item))
      .join("|");
    const hash = createHash("sha256").update(dataString).digest("hex").substring(0, 16);
    this.logger.silly(`Created hash for input incidents: ${hash}`);
    return hash;
  }
}
